<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>0xio Wallet Recovery Tool - Mnemonic to Address & Private Key</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 600px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 24px;
            text-align: center;
        }

        .subtitle {
            color: #666;
            text-align: center;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .button {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 10px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .button:active {
            transform: translateY(0);
        }

        .output-section {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            display: none;
        }

        .output-section.visible {
            display: block;
        }

        .output-item {
            margin-bottom: 15px;
        }

        .output-label {
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .output-value {
            padding: 12px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            word-break: break-all;
            color: #333;
            position: relative;
        }

        .copy-btn {
            position: absolute;
            right: 8px;
            top: 8px;
            padding: 6px 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .copy-btn:hover {
            background: #5568d3;
        }

        .error {
            color: #e74c3c;
            background: #ffe6e6;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 14px;
            display: none;
        }

        .error.visible {
            display: block;
        }

        .loading {
            text-align: center;
            color: #667eea;
            font-weight: 500;
            margin-top: 10px;
            display: none;
        }

        .loading.visible {
            display: block;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #1976d2;
        }

        .warning-box {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #e65100;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>0xio Wallet Recovery Tool</h1>
        <p class="subtitle">Recover your wallet address and private key from your seed phrase</p>

        <div class="warning-box">
            <strong>⚠️ Security Warning:</strong> Never share your seed phrase or private key with anyone. This tool runs entirely in your browser and does not transmit any data.
        </div>

        <div class="info-box">
            <strong>ℹ️ Info:</strong> Enter your 12-word BIP39 seed phrase below to recover your wallet credentials.
        </div>

        <div class="input-group">
            <label for="mnemonic">Seed Phrase (12 words)</label>
            <textarea id="mnemonic" rows="3" placeholder="word1 word2 word3 word4 word5 word6 word7 word8 word9 word10 word11 word12"></textarea>
        </div>

        <button class="button" onclick="recoverWallet()">Recover Wallet</button>

        <div class="loading" id="loading">Processing your seed phrase...</div>
        <div class="error" id="error"></div>

        <div class="output-section" id="output">
            <h3 style="margin-bottom: 15px; color: #333;">Wallet Information</h3>

            <div class="output-item">
                <div class="output-label">Address</div>
                <div class="output-value" style="padding-right: 80px;">
                    <span id="address"></span>
                    <button class="copy-btn" onclick="copyToClipboard('address')">Copy</button>
                </div>
            </div>

            <div class="output-item">
                <div class="output-label">Private Key (Base64)</div>
                <div class="output-value" style="padding-right: 80px;">
                    <span id="privateKey"></span>
                    <button class="copy-btn" onclick="copyToClipboard('privateKey')">Copy</button>
                </div>
            </div>

            <div class="output-item">
                <div class="output-label">Public Key (Base64)</div>
                <div class="output-value" style="padding-right: 80px;">
                    <span id="publicKey"></span>
                    <button class="copy-btn" onclick="copyToClipboard('publicKey')">Copy</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load TweetNaCl library -->
    <script src="libs/nacl.min.js"></script>

    <script>
        // Crypto utility class - extracted from crypto.js
        class WalletRecovery {
            constructor() {
                this.privateKey = null;
                this.publicKey = null;
                this.signingKey = null;
            }

            // Convert string to bytes
            stringToBytes(str) {
                return new TextEncoder().encode(str);
            }

            // Convert bytes to base64
            bytesToBase64(bytes) {
                let binary = '';
                for (let i = 0; i < bytes.length; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            // Convert bytes to hex
            bytesToHex(bytes) {
                return Array.from(bytes)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
            }

            // Convert hex to bytes
            hexToBytes(hex) {
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < hex.length; i += 2) {
                    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
                }
                return bytes;
            }

            // SHA-256 hash
            async sha256(data) {
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                return new Uint8Array(hashBuffer);
            }

            // Synchronous SHA-256 using nacl
            sha256Sync(data) {
                return nacl.hash(data).slice(0, 32);
            }

            // Base58 encoding
            bytesToBase58(bytes) {
                const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

                if (bytes.length === 0) return '';
                let num = 0n;
                for (let i = 0; i < bytes.length; i++) {
                    num = num * 256n + BigInt(bytes[i]);
                }
                let encoded = '';
                while (num > 0n) {
                    const remainder = num % 58n;
                    num = num / 58n;
                    encoded = alphabet[Number(remainder)] + encoded;
                }
                for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
                    encoded = '1' + encoded;
                }

                return encoded;
            }

            // HMAC-SHA512
            async hmacSha512(key, data) {
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    key,
                    { name: 'HMAC', hash: 'SHA-512' },
                    false,
                    ['sign']
                );

                const signature = await crypto.subtle.sign('HMAC', cryptoKey, data);
                return new Uint8Array(signature);
            }

            // Convert mnemonic to seed using PBKDF2
            async mnemonicToSeed(mnemonic, passphrase = "") {
                const mnemonicBuffer = this.stringToBytes(mnemonic);
                const saltBuffer = this.stringToBytes("mnemonic" + passphrase);

                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    mnemonicBuffer,
                    'PBKDF2',
                    false,
                    ['deriveBits']
                );

                const derivedBits = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: saltBuffer,
                        iterations: 2048,
                        hash: 'SHA-512'
                    },
                    keyMaterial,
                    512 // 64 bytes
                );

                return new Uint8Array(derivedBits);
            }

            // Derive master key using "Octra seed" HMAC
            async deriveMasterKey(seed) {
                const key = this.stringToBytes("Octra seed");
                const hmac = await this.hmacSha512(key, seed);

                return {
                    privateKey: hmac.slice(0, 32),
                    chainCode: hmac.slice(32, 64)
                };
            }

            // Derive address from public key
            async deriveAddress(publicKey) {
                try {
                    const publicKeyBytes = this.base64ToBytes(publicKey);
                    const hash = await this.sha256(publicKeyBytes);
                    const base58Hash = this.bytesToBase58(hash);
                    return 'oct' + base58Hash;
                } catch (error) {
                    throw new Error('Failed to derive address: ' + error.message);
                }
            }

            // Convert base64 to bytes
            base64ToBytes(base64) {
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes;
            }

            // Main recovery function: mnemonic -> address + private key
            async recoverFromMnemonic(mnemonic) {
                try {
                    // Normalize mnemonic (trim and single space)
                    const normalizedMnemonic = mnemonic.trim().toLowerCase().replace(/\s+/g, ' ');

                    // Validate word count
                    const words = normalizedMnemonic.split(' ');
                    if (words.length !== 12) {
                        throw new Error(`Invalid mnemonic: expected 12 words, got ${words.length}`);
                    }

                    // Convert mnemonic to seed
                    const seed = await this.mnemonicToSeed(normalizedMnemonic);

                    // Derive master key
                    const masterKey = await this.deriveMasterKey(seed);

                    // Create signing key pair
                    this.signingKey = nacl.sign.keyPair.fromSeed(masterKey.privateKey);

                    const privateKeyRaw = masterKey.privateKey;
                    const publicKeyRaw = this.signingKey.publicKey;

                    const privateKeyB64 = this.bytesToBase64(privateKeyRaw);
                    const publicKeyB64 = this.bytesToBase64(publicKeyRaw);

                    // Derive address
                    const address = await this.deriveAddress(publicKeyB64);

                    this.privateKey = privateKeyB64;
                    this.publicKey = publicKeyB64;

                    return {
                        success: true,
                        address: address,
                        privateKey: privateKeyB64,
                        publicKey: publicKeyB64,
                        seedHex: this.bytesToHex(seed),
                        privateKeyHex: this.bytesToHex(privateKeyRaw),
                        publicKeyHex: this.bytesToHex(publicKeyRaw)
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }
        }

        // Global recovery instance
        const recovery = new WalletRecovery();

        // Recover wallet function
        async function recoverWallet() {
            const mnemonicInput = document.getElementById('mnemonic');
            const loading = document.getElementById('loading');
            const error = document.getElementById('error');
            const output = document.getElementById('output');

            // Reset UI
            error.classList.remove('visible');
            output.classList.remove('visible');
            loading.classList.add('visible');

            const mnemonic = mnemonicInput.value.trim();

            if (!mnemonic) {
                loading.classList.remove('visible');
                error.textContent = 'Please enter your seed phrase';
                error.classList.add('visible');
                return;
            }

            try {
                const result = await recovery.recoverFromMnemonic(mnemonic);

                loading.classList.remove('visible');

                if (result.success) {
                    // Display results
                    document.getElementById('address').textContent = result.address;
                    document.getElementById('privateKey').textContent = result.privateKey;
                    document.getElementById('publicKey').textContent = result.publicKey;
                    output.classList.add('visible');
                } else {
                    error.textContent = result.error || 'Failed to recover wallet';
                    error.classList.add('visible');
                }
            } catch (err) {
                loading.classList.remove('visible');
                error.textContent = 'An unexpected error occurred: ' + err.message;
                error.classList.add('visible');
            }
        }

        // Copy to clipboard function
        async function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            const text = element.textContent;

            try {
                await navigator.clipboard.writeText(text);

                // Visual feedback
                const btn = element.nextElementSibling;
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.style.background = '#4caf50';

                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#667eea';
                }, 2000);
            } catch (err) {
                alert('Failed to copy to clipboard');
            }
        }

        // Allow Enter key to trigger recovery
        document.getElementById('mnemonic').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                recoverWallet();
            }
        });
    </script>
</body>
</html>
